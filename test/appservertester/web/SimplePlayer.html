<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DASH Player - DEBUG MODE</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Consolas', 'Monaco', monospace;
            background: #1a1a2e;
            color: #eee;
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
        }

        h1 {
            color: #00ff88;
            margin-bottom: 20px;
            font-size: 20px;
        }

        .input-group {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
        }

        input[type="text"] {
            flex: 1;
            padding: 10px;
            border: 2px solid #333;
            border-radius: 4px;
            background: #0f0f1a;
            color: #fff;
            font-family: inherit;
        }

        button {
            padding: 10px 20px;
            background: #00ff88;
            color: #000;
            border: none;
            border-radius: 4px;
            font-weight: bold;
            cursor: pointer;
        }

            button:hover {
                background: #00cc6a;
            }

            button.danger {
                background: #ff4444;
                color: #fff;
            }

        .main-content {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
        }

        .video-section {
            background: #0f0f1a;
            border-radius: 8px;
            padding: 15px;
            border: 1px solid #333;
        }

        video {
            width: 100%;
            height: auto;
            background: #000;
            border-radius: 4px;
        }

        .debug-section {
            background: #0f0f1a;
            border-radius: 8px;
            padding: 15px;
            border: 1px solid #333;
            max-height: 600px;
            overflow-y: auto;
        }

        .debug-title {
            color: #00ff88;
            margin-bottom: 10px;
            font-size: 14px;
            border-bottom: 1px solid #333;
            padding-bottom: 5px;
        }

        .log-entry {
            font-size: 11px;
            padding: 4px 8px;
            margin: 2px 0;
            border-radius: 2px;
            word-break: break-all;
        }

        .log-info {
            background: #1a3a5c;
            color: #7ec8e3;
        }

        .log-success {
            background: #1a3c1a;
            color: #7ee37e;
        }

        .log-warning {
            background: #3c3a1a;
            color: #e3e37e;
        }

        .log-error {
            background: #3c1a1a;
            color: #e37e7e;
        }

        .log-data {
            background: #2a1a3c;
            color: #c87ee3;
        }

        .hex-dump {
            font-size: 10px;
            background: #000;
            padding: 10px;
            border-radius: 4px;
            overflow-x: auto;
            white-space: pre;
            color: #888;
            max-height: 200px;
            overflow-y: auto;
        }

        .box-info {
            display: inline-block;
            background: #333;
            padding: 2px 6px;
            border-radius: 3px;
            margin: 2px;
            font-size: 10px;
        }

        .status-panel {
            background: #0f0f1a;
            border-radius: 8px;
            padding: 15px;
            border: 1px solid #333;
            margin-top: 20px;
        }

        .status-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 10px;
        }

        .status-item {
            background: #1a1a2e;
            padding: 10px;
            border-radius: 4px;
            text-align: center;
        }

        .status-label {
            font-size: 10px;
            color: #888;
            margin-bottom: 5px;
        }

        .status-value {
            font-size: 14px;
            color: #00ff88;
        }

        .error-details {
            background: #2a0a0a;
            border: 1px solid #ff4444;
            border-radius: 4px;
            padding: 15px;
            margin-top: 10px;
        }

            .error-details h3 {
                color: #ff4444;
                margin-bottom: 10px;
            }

            .error-details pre {
                font-size: 11px;
                white-space: pre-wrap;
                color: #ffaaaa;
            }

        .controls {
            margin-top: 10px;
            display: flex;
            gap: 10px;
        }

            .controls button {
                flex: 1;
                padding: 8px;
                font-size: 12px;
            }
    </style>
</head>
<body>
    <div class="container">
        <h1>🔍 DASH Player - DEBUG MODE</h1>

        <div class="input-group">
            <input type="text" id="videoName" placeholder="Nome do vídeo" value="sample-3">
            <button onclick="playVideo()">▶ Play</button>
            <button class="danger" onclick="stopVideo()">⏹ Stop</button>
            <button onclick="clearLogs()">🗑 Clear Logs</button>
            <button onclick="downloadLogs()">💾 Export Logs</button>
        </div>

        <div class="main-content">
            <div class="video-section">
                <div class="debug-title">📺 Video Player</div>
                <video id="videoPlayer" controls></video>
                <div class="controls">
                    <button onclick="analyzeBuffer()">📊 Analyze Buffer</button>
                    <button onclick="testManualAppend()">🧪 Test Manual Append</button>
                </div>
            </div>

            <div class="debug-section" id="debugLog">
                <div class="debug-title">📋 Debug Log</div>
            </div>
        </div>

        <div class="status-panel">
            <div class="debug-title">📈 Status</div>
            <div class="status-grid">
                <div class="status-item">
                    <div class="status-label">MediaSource State</div>
                    <div class="status-value" id="msState">-</div>
                </div>
                <div class="status-item">
                    <div class="status-label">SourceBuffer State</div>
                    <div class="status-value" id="sbState">-</div>
                </div>
                <div class="status-item">
                    <div class="status-label">Current Fragment</div>
                    <div class="status-value" id="fragNum">-</div>
                </div>
                <div class="status-item">
                    <div class="status-label">Buffer Length</div>
                    <div class="status-value" id="bufLen">-</div>
                </div>
            </div>
        </div>

        <div id="errorDetails" class="error-details" style="display: none;">
            <h3>❌ Error Details</h3>
            <pre id="errorContent"></pre>
        </div>

        <div class="status-panel">
            <div class="debug-title">🔬 Last Segment Analysis</div>
            <div id="segmentAnalysis">Nenhum segmento analisado ainda.</div>
        </div>
    </div>

    <script>
        // ════════════════════════════════════════════════════════════════════
        // CONFIGURAÇÃO
        // ════════════════════════════════════════════════════════════════════

        const BaseUrl = "http://localhost:1234/api";
        const logs = [];

        // ════════════════════════════════════════════════════════════════════
        // FUNÇÕES DE LOG
        // ════════════════════════════════════════════════════════════════════

        function log(type, message, data = null) {
            const timestamp = new Date().toISOString().substr(11, 12);
            const entry = { timestamp, type, message, data };
            logs.push(entry);

            const logDiv = document.getElementById('debugLog');
            const entryDiv = document.createElement('div');
            entryDiv.className = `log-entry log-${type}`;

            let content = `[${timestamp}] ${message}`;
            if (data) {
                if (typeof data === 'object') {
                    content += '\n' + JSON.stringify(data, null, 2);
                } else {
                    content += ` | ${data}`;
                }
            }

            entryDiv.textContent = content;
            logDiv.appendChild(entryDiv);
            logDiv.scrollTop = logDiv.scrollHeight;

            // Console também
            console.log(`[${type.toUpperCase()}]`, message, data || '');
        }

        function clearLogs() {
            logs.length = 0;
            document.getElementById('debugLog').innerHTML = '<div class="debug-title">📋 Debug Log</div>';
            document.getElementById('errorDetails').style.display = 'none';
        }

        function downloadLogs() {
            const content = logs.map(l =>
                `[${l.timestamp}] [${l.type}] ${l.message}${l.data ? '\n' + JSON.stringify(l.data, null, 2) : ''}`
            ).join('\n\n');

            const blob = new Blob([content], { type: 'text/plain' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `dash-debug-${Date.now()}.log`;
            a.click();
        }

        function showError(title, details) {
            const errorDiv = document.getElementById('errorDetails');
            const contentDiv = document.getElementById('errorContent');

            errorDiv.style.display = 'block';
            contentDiv.textContent = `${title}\n\n${details}`;

            log('error', title, details);
        }

        function updateStatus() {
            document.getElementById('msState').textContent =
                player.mediaSource ? player.mediaSource.readyState : '-';
            document.getElementById('sbState').textContent =
                player.sourceBuffer ? (player.sourceBuffer.updating ? 'updating' : 'ready') : '-';
            document.getElementById('fragNum').textContent =
                `${player.currentFragment}/${player.totalFragments}`;

            if (player.sourceBuffer && player.sourceBuffer.buffered.length > 0) {
                const start = player.sourceBuffer.buffered.start(0).toFixed(2);
                const end = player.sourceBuffer.buffered.end(0).toFixed(2);
                document.getElementById('bufLen').textContent = `${start}s - ${end}s`;
            } else {
                document.getElementById('bufLen').textContent = '-';
            }
        }

        // ════════════════════════════════════════════════════════════════════
        // ANÁLISE DE MP4
        // ════════════════════════════════════════════════════════════════════

        function analyzeMP4Boxes(data, label) {
            const view = new DataView(data);
            const boxes = [];
            let offset = 0;

            log('data', `Analisando ${label}: ${data.byteLength} bytes`);

            while (offset < data.byteLength - 8) {
                try {
                    let size = view.getUint32(offset);
                    const type = String.fromCharCode(
                        view.getUint8(offset + 4),
                        view.getUint8(offset + 5),
                        view.getUint8(offset + 6),
                        view.getUint8(offset + 7)
                    );

                    // Handle size == 1 (extended size)
                    let headerSize = 8;
                    if (size === 1 && offset + 16 <= data.byteLength) {
                        const highBits = view.getUint32(offset + 8);
                        const lowBits = view.getUint32(offset + 12);
                        size = highBits * 0x100000000 + lowBits;
                        headerSize = 16;
                    }

                    // Handle size == 0 (extends to end of file)
                    if (size === 0) {
                        size = data.byteLength - offset;
                    }

                    // Validação
                    if (size < 8 || offset + size > data.byteLength) {
                        log('warning', `Box inválido em offset ${offset}: size=${size}, remaining=${data.byteLength - offset}`);
                        break;
                    }

                    const box = {
                        type,
                        size,
                        offset,
                        headerSize
                    };

                    boxes.push(box);
                    log('info', `Box encontrado: '${type}' size=${size} offset=${offset}`);

                    // Análise específica por tipo
                    if (type === 'ftyp') {
                        analyzeFtyp(view, offset, size);
                    } else if (type === 'moov') {
                        log('success', 'moov box encontrado (initialization segment OK)');
                        analyzeContainerBox(view, offset + headerSize, size - headerSize, 1);
                    } else if (type === 'moof') {
                        log('success', 'moof box encontrado (fragment header)');
                        analyzeContainerBox(view, offset + headerSize, size - headerSize, 1);
                    } else if (type === 'mdat') {
                        log('success', `mdat box encontrado: ${size - headerSize} bytes de dados de vídeo`);
                    }

                    offset += size;
                } catch (e) {
                    log('error', `Erro ao analisar box em offset ${offset}: ${e.message}`);
                    break;
                }
            }

            // Mostrar análise visual
            const analysisDiv = document.getElementById('segmentAnalysis');
            analysisDiv.innerHTML = `
                    <div style="margin-bottom: 10px;"><strong>${label}</strong> (${data.byteLength} bytes)</div>
                    <div>
                        ${boxes.map(b => `<span class="box-info">${b.type} (${b.size}B)</span>`).join(' ')}
                    </div>
                    <div class="hex-dump">${hexDump(data, 0, Math.min(256, data.byteLength))}</div>
                `;

            return boxes;
        }

        function analyzeFtyp(view, offset, size) {
            try {
                const majorBrand = String.fromCharCode(
                    view.getUint8(offset + 8),
                    view.getUint8(offset + 9),
                    view.getUint8(offset + 10),
                    view.getUint8(offset + 11)
                );
                const minorVersion = view.getUint32(offset + 12);

                log('info', `ftyp: majorBrand='${majorBrand}', minorVersion=${minorVersion}`);

                // Compatible brands
                const brands = [];
                for (let i = 16; i < size; i += 4) {
                    const brand = String.fromCharCode(
                        view.getUint8(offset + i),
                        view.getUint8(offset + i + 1),
                        view.getUint8(offset + i + 2),
                        view.getUint8(offset + i + 3)
                    );
                    if (brand.trim()) brands.push(brand);
                }
                log('info', `ftyp: compatibleBrands=[${brands.join(', ')}]`);
            } catch (e) {
                log('warning', `Erro ao analisar ftyp: ${e.message}`);
            }
        }

        function analyzeContainerBox(view, offset, size, depth) {
            const indent = '  '.repeat(depth);
            let pos = offset;
            const end = offset + size;

            while (pos < end - 8) {
                try {
                    let boxSize = view.getUint32(pos);
                    const boxType = String.fromCharCode(
                        view.getUint8(pos + 4),
                        view.getUint8(pos + 5),
                        view.getUint8(pos + 6),
                        view.getUint8(pos + 7)
                    );

                    if (boxSize === 0) boxSize = end - pos;
                    if (boxSize < 8 || pos + boxSize > end) break;

                    log('info', `${indent}├─ ${boxType} (${boxSize} bytes)`);

                    // Recursão para containers conhecidos
                    const containers = ['moov', 'trak', 'mdia', 'minf', 'stbl', 'mvex', 'moof', 'traf'];
                    if (containers.includes(boxType) && depth < 5) {
                        analyzeContainerBox(view, pos + 8, boxSize - 8, depth + 1);
                    }

                    // Análise específica
                    if (boxType === 'tfdt') {
                        analyzeTfdt(view, pos);
                    } else if (boxType === 'trun') {
                        analyzeTrun(view, pos, boxSize);
                    } else if (boxType === 'mfhd') {
                        analyzeMfhd(view, pos);
                    }

                    pos += boxSize;
                } catch (e) {
                    break;
                }
            }
        }

        function analyzeMfhd(view, offset) {
            try {
                const version = view.getUint8(offset + 8);
                const sequenceNumber = view.getUint32(offset + 12);
                log('info', `    mfhd: version=${version}, sequenceNumber=${sequenceNumber}`);
            } catch (e) { }
        }

        function analyzeTfdt(view, offset) {
            try {
                const version = view.getUint8(offset + 8);
                let baseMediaDecodeTime;
                if (version === 1) {
                    const high = view.getUint32(offset + 12);
                    const low = view.getUint32(offset + 16);
                    baseMediaDecodeTime = high * 0x100000000 + low;
                } else {
                    baseMediaDecodeTime = view.getUint32(offset + 12);
                }
                log('info', `    tfdt: version=${version}, baseMediaDecodeTime=${baseMediaDecodeTime}`);
            } catch (e) { }
        }

        function analyzeTrun(view, offset, size) {
            try {
                const version = view.getUint8(offset + 8);
                const flags = (view.getUint8(offset + 9) << 16) |
                    (view.getUint8(offset + 10) << 8) |
                    view.getUint8(offset + 11);
                const sampleCount = view.getUint32(offset + 12);

                log('info', `    trun: version=${version}, flags=0x${flags.toString(16)}, sampleCount=${sampleCount}`);

                // Verificar flags
                const hasDataOffset = (flags & 0x000001) !== 0;
                const hasFirstSampleFlags = (flags & 0x000004) !== 0;
                const hasSampleDuration = (flags & 0x000100) !== 0;
                const hasSampleSize = (flags & 0x000200) !== 0;
                const hasSampleFlags = (flags & 0x000400) !== 0;
                const hasSampleCTO = (flags & 0x000800) !== 0;

                log('info', `    trun flags: dataOffset=${hasDataOffset}, firstSampleFlags=${hasFirstSampleFlags}, duration=${hasSampleDuration}, size=${hasSampleSize}`);

                let pos = offset + 16;
                if (hasDataOffset) {
                    const dataOffset = view.getInt32(pos);
                    log('info', `    trun: dataOffset=${dataOffset}`);
                    pos += 4;
                }
            } catch (e) { }
        }

        function hexDump(data, offset, length) {
            const bytes = new Uint8Array(data, offset, length);
            let result = '';

            for (let i = 0; i < bytes.length; i += 16) {
                // Offset
                result += i.toString(16).padStart(8, '0') + '  ';

                // Hex bytes
                for (let j = 0; j < 16; j++) {
                    if (i + j < bytes.length) {
                        result += bytes[i + j].toString(16).padStart(2, '0') + ' ';
                    } else {
                        result += '   ';
                    }
                    if (j === 7) result += ' ';
                }

                result += ' |';

                // ASCII
                for (let j = 0; j < 16 && i + j < bytes.length; j++) {
                    const byte = bytes[i + j];
                    result += (byte >= 32 && byte <= 126) ? String.fromCharCode(byte) : '.';
                }

                result += '|\n';
            }

            return result;
        }

        // ════════════════════════════════════════════════════════════════════
        // PLAYER DASH COM DEBUG
        // ════════════════════════════════════════════════════════════════════

        class DebugDASHPlayer {
            constructor(videoElement, baseUrl) {
                this.video = videoElement;
                this.mediaSource = null;
                this.sourceBuffer = null;
                this.currentFragment = 0;
                this.totalFragments = 0;
                this.isPlaying = false;
                this.baseUrl = baseUrl;
                this.videoName = '';
                this.lastInitData = null;
                this.lastFragmentData = null;
                this.codec = '';

                // Adicionar listeners de erro no vídeo
                this.video.addEventListener('error', (e) => {
                    const error = this.video.error;
                    showError('Video Element Error', `
Code: ${error ? error.code : 'unknown'}
Message: ${error ? error.message : 'unknown'}
MEDIA_ERR_ABORTED: ${error?.code === 1}
MEDIA_ERR_NETWORK: ${error?.code === 2}
MEDIA_ERR_DECODE: ${error?.code === 3}
MEDIA_ERR_SRC_NOT_SUPPORTED: ${error?.code === 4}
                        `);
                });
            }

            async play(videoName) {
                if (this.isPlaying) {
                    this.stop();
                }

                this.videoName = videoName;
                this.currentFragment = 0;
                this.isPlaying = true;

                log('info', `Iniciando reprodução: ${videoName}`);

                try {
                    // 1. Buscar e parsear MPD
                    log('info', 'Buscando MPD...');
                    const mpd = await this.fetchMPD();
                    log('success', 'MPD carregado', mpd);

                    // 2. Configurar MediaSource
                    log('info', 'Configurando MediaSource...');
                    await this.setupMediaSource(mpd.codec);
                    log('success', 'MediaSource configurado');

                    // 3. Carregar Initialization Segment
                    log('info', 'Carregando init segment...');
                    const initSegment = await this.fetchInitSegment();
                    this.lastInitData = initSegment;

                    // Analisar init segment
                    analyzeMP4Boxes(initSegment, 'Init Segment (init.mp4)');

                    log('info', `Init segment: ${initSegment.byteLength} bytes`);
                    await this.appendBuffer(initSegment, 'init');
                    log('success', 'Init segment appendado com sucesso');

                    // 4. Começar a carregar fragmentos
                    this.loadNextFragment();

                } catch (error) {
                    showError('Erro Fatal', `
Message: ${error.message}
Stack: ${error.stack}
                        `);
                    this.isPlaying = false;
                }

                updateStatus();
            }

            stop() {
                log('info', 'Parando reprodução...');
                this.isPlaying = false;
                this.currentFragment = 0;

                if (this.sourceBuffer && !this.sourceBuffer.updating) {
                    try {
                        this.sourceBuffer.abort();
                    } catch (e) {
                        log('warning', `Erro ao abortar sourceBuffer: ${e.message}`);
                    }
                }

                if (this.mediaSource && this.mediaSource.readyState === 'open') {
                    try {
                        this.mediaSource.endOfStream();
                    } catch (e) {
                        log('warning', `Erro ao finalizar mediaSource: ${e.message}`);
                    }
                }

                this.video.src = '';
                this.mediaSource = null;
                this.sourceBuffer = null;

                updateStatus();
            }

            async fetchMPD() {
                const url = `${this.baseUrl}/${this.videoName}.mpd`;
                log('info', `Fetching MPD: ${url}`);

                const response = await fetch(url);

                if (!response.ok) {
                    throw new Error(`MPD não encontrado: ${response.status} ${response.statusText}`);
                }

                const text = await response.text();
                log('data', 'MPD Content:', text.substring(0, 500));

                return this.parseMPD(text);
            }

            parseMPD(xmlText) {
                const parser = new DOMParser();
                const xml = parser.parseFromString(xmlText, 'text/xml');

                // Check for parse errors
                const parseError = xml.querySelector('parsererror');
                if (parseError) {
                    throw new Error(`XML Parse Error: ${parseError.textContent}`);
                }

                const adaptationSet = xml.querySelector('AdaptationSet');
                const codec = adaptationSet?.getAttribute('codecs') || 'avc1.64001f';
                this.codec = codec;

                const mpd = xml.querySelector('MPD');
                const durationStr = mpd?.getAttribute('mediaPresentationDuration') || 'PT0S';
                const totalSeconds = this.parseDuration(durationStr);

                const segmentTemplate = xml.querySelector('SegmentTemplate');
                const timescale = parseInt(segmentTemplate?.getAttribute('timescale') || '90000');
                const duration = parseInt(segmentTemplate?.getAttribute('duration') || '180000');
                const fragmentDuration = duration / timescale;

                this.totalFragments = Math.ceil(totalSeconds / fragmentDuration);

                log('info', `MPD Parsed: codec=${codec}, duration=${totalSeconds}s, fragments=${this.totalFragments}`);

                return {
                    codec: codec,
                    totalSeconds: totalSeconds,
                    fragmentDuration: fragmentDuration,
                    totalFragments: this.totalFragments,
                    timescale: timescale
                };
            }

            parseDuration(duration) {
                const matches = duration.match(/PT(?:(\d+)M)?(?:(\d+)S)?/);
                const minutes = parseInt(matches?.[1] || '0');
                const seconds = parseInt(matches?.[2] || '0');
                return minutes * 60 + seconds;
            }

            async setupMediaSource(codec) {
                return new Promise((resolve, reject) => {
                    this.mediaSource = new MediaSource();
                    this.video.src = URL.createObjectURL(this.mediaSource);

                    this.mediaSource.addEventListener('sourceopen', () => {
                        try {
                            const mimeType = `video/mp4; codecs="${codec}"`;
                            log('info', `Tentando MIME type: ${mimeType}`);

                            if (!MediaSource.isTypeSupported(mimeType)) {
                                // Tentar variações comuns
                                const alternatives = [
                                    'video/mp4; codecs="avc1.64001f"',
                                    'video/mp4; codecs="avc1.640028"',
                                    'video/mp4; codecs="avc1.4d401f"',
                                    'video/mp4; codecs="avc1.42E01E"',
                                    'video/mp4; codecs="avc1.42001E"',
                                    'video/mp4'
                                ];

                                let found = false;
                                for (const alt of alternatives) {
                                    if (MediaSource.isTypeSupported(alt)) {
                                        log('warning', `Codec original não suportado, usando: ${alt}`);
                                        this.sourceBuffer = this.mediaSource.addSourceBuffer(alt);
                                        found = true;
                                        break;
                                    }
                                }

                                if (!found) {
                                    reject(new Error(`Nenhum codec suportado. Original: ${mimeType}`));
                                    return;
                                }
                            } else {
                                this.sourceBuffer = this.mediaSource.addSourceBuffer(mimeType);
                            }

                            // Configurar sourceBuffer
                            this.sourceBuffer.mode = 'segments';

                            // Listeners para debug
                            this.sourceBuffer.addEventListener('updateend', () => {
                                log('info', 'SourceBuffer: updateend');
                                updateStatus();
                            });

                            this.sourceBuffer.addEventListener('error', (e) => {
                                log('error', 'SourceBuffer error event', e);
                            });

                            this.sourceBuffer.addEventListener('abort', () => {
                                log('warning', 'SourceBuffer: abort');
                            });

                            resolve();
                        } catch (error) {
                            reject(error);
                        }
                    });

                    this.mediaSource.addEventListener('sourceended', () => {
                        log('info', 'MediaSource: sourceended');
                    });

                    this.mediaSource.addEventListener('sourceclose', () => {
                        log('warning', 'MediaSource: sourceclose');
                    });

                    this.mediaSource.addEventListener('error', (e) => {
                        log('error', 'MediaSource error', e);
                        reject(new Error('MediaSource error'));
                    });
                });
            }

            async fetchInitSegment() {
                const url = `${this.baseUrl}/init.mp4?video=${this.videoName}`;
                log('info', `Fetching init: ${url}`);

                const response = await fetch(url);

                if (!response.ok) {
                    const text = await response.text();
                    throw new Error(`Init segment error: ${response.status} - ${text}`);
                }

                const data = await response.arrayBuffer();
                log('success', `Init segment recebido: ${data.byteLength} bytes`);

                return data;
            }

            async fetchFragment(number) {
                const url = `${this.baseUrl}/fragment_${number}.m4s?video=${this.videoName}`;
                log('info', `Fetching fragment: ${url}`);

                const response = await fetch(url);

                if (!response.ok) {
                    const text = await response.text();
                    throw new Error(`Fragment ${number} error: ${response.status} - ${text}`);
                }

                const data = await response.arrayBuffer();
                log('success', `Fragment ${number} recebido: ${data.byteLength} bytes`);

                return data;
            }

            async loadNextFragment() {
                if (!this.isPlaying || this.currentFragment >= this.totalFragments) {
                    if (this.mediaSource && this.mediaSource.readyState === 'open') {
                        log('info', 'Finalizando stream...');
                        this.mediaSource.endOfStream();
                    }
                    return;
                }

                try {
                    const fragment = await this.fetchFragment(this.currentFragment);
                    this.lastFragmentData = fragment;

                    // Analisar fragmento
                    analyzeMP4Boxes(fragment, `Fragment ${this.currentFragment}`);

                    await this.appendBuffer(fragment, `fragment_${this.currentFragment}`);

                    log('success', `Fragment ${this.currentFragment} appendado`);

                    this.currentFragment++;
                    updateStatus();

                    // Carregar próximo
                    this.loadNextFragment();

                } catch (error) {
                    showError(`Erro no Fragment ${this.currentFragment}`, `
Message: ${error.message}
Stack: ${error.stack}

MediaSource state: ${this.mediaSource?.readyState}
SourceBuffer updating: ${this.sourceBuffer?.updating}
SourceBuffer mode: ${this.sourceBuffer?.mode}
Video error: ${this.video.error?.message || 'none'}
                        `);
                }
            }

            appendBuffer(data, label) {
                return new Promise((resolve, reject) => {
                    if (!this.sourceBuffer) {
                        reject(new Error('SourceBuffer não existe'));
                        return;
                    }

                    if (this.mediaSource.readyState !== 'open') {
                        reject(new Error(`MediaSource não está aberto: ${this.mediaSource.readyState}`));
                        return;
                    }

                    log('info', `appendBuffer: ${label}, ${data.byteLength} bytes, updating=${this.sourceBuffer.updating}`);

                    const doAppend = () => {
                        try {
                            log('info', `Executando appendBuffer para ${label}...`);
                            this.sourceBuffer.appendBuffer(data);
                        } catch (error) {
                            // Capturar erro síncrono do appendBuffer
                            showError(`appendBuffer sync error (${label})`, `
Error: ${error.name}
Message: ${error.message}

Possíveis causas:
- QuotaExceededError: Buffer cheio
- InvalidStateError: SourceBuffer em estado inválido
- InvalidAccessError: Dados inválidos

Data size: ${data.byteLength} bytes
First 8 bytes: ${Array.from(new Uint8Array(data, 0, 8)).map(b => b.toString(16).padStart(2, '0')).join(' ')}
                                `);
                            reject(error);
                            return;
                        }
                    };

                    // Handler para quando terminar
                    const onUpdateEnd = () => {
                        log('info', `appendBuffer concluído: ${label}`);
                        cleanup();
                        resolve();
                    };

                    // Handler para erro
                    const onError = (e) => {
                        // Coletar informações detalhadas
                        const errorInfo = {
                            label: label,
                            dataSize: data.byteLength,
                            mediaSourceState: this.mediaSource?.readyState,
                            sourceBufferUpdating: this.sourceBuffer?.updating,
                            sourceBufferMode: this.sourceBuffer?.mode,
                            videoError: this.video.error,
                            videoReadyState: this.video.readyState,
                            videoNetworkState: this.video.networkState,
                            bufferedRanges: this.sourceBuffer?.buffered?.length > 0 ?
                                `${this.sourceBuffer.buffered.start(0)} - ${this.sourceBuffer.buffered.end(0)}` : 'none'
                        };

                        // Analisar os dados que falharam
                        log('error', `appendBuffer ERRO para ${label}`, errorInfo);

                        // Verificar estrutura do MP4
                        const view = new DataView(data);
                        const firstBoxType = String.fromCharCode(
                            view.getUint8(4), view.getUint8(5), view.getUint8(6), view.getUint8(7)
                        );

                        showError(`appendBuffer Error (${label})`, `
═══════════════════════════════════════════════════
ERRO NO SOURCEBUFFER
═══════════════════════════════════════════════════

Label: ${label}
Data size: ${data.byteLength} bytes
First box type: '${firstBoxType}'

MediaSource state: ${errorInfo.mediaSourceState}
SourceBuffer updating: ${errorInfo.sourceBufferUpdating}
SourceBuffer mode: ${errorInfo.sourceBufferMode}
Buffered ranges: ${errorInfo.bufferedRanges}

Video element:
      - readyState: ${errorInfo.videoReadyState}
      - networkState: ${errorInfo.videoNetworkState}
      - error: ${errorInfo.videoError?.message || 'none'}

═══════════════════════════════════════════════════
DIAGNÓSTICO
═══════════════════════════════════════════════════

${this.diagnoseError(data, label)}

═══════════════════════════════════════════════════
FIRST 64 BYTES (HEX)
═══════════════════════════════════════════════════
${Array.from(new Uint8Array(data, 0, Math.min(64, data.byteLength)))
                                .map((b, i) => (i % 16 === 0 ? '\n' : '') + b.toString(16).padStart(2, '0'))
                                .join(' ')}
                            `);

                        cleanup();
                        reject(new Error(`appendBuffer failed for ${label}`));
                    };

                    const cleanup = () => {
                        this.sourceBuffer.removeEventListener('updateend', onUpdateEnd);
                        this.sourceBuffer.removeEventListener('error', onError);
                    };

                    this.sourceBuffer.addEventListener('updateend', onUpdateEnd, { once: true });
                    this.sourceBuffer.addEventListener('error', onError, { once: true });

                    // Aguardar se estiver atualizando
                    if (this.sourceBuffer.updating) {
                        log('warning', 'SourceBuffer ocupado, aguardando...');
                        this.sourceBuffer.addEventListener('updateend', doAppend, { once: true });
                    } else {
                        doAppend();
                    }
                });
            }

            diagnoseError(data, label) {
                const issues = [];
                const view = new DataView(data);

                // 1. Verificar se tem tamanho mínimo
                if (data.byteLength < 8) {
                    issues.push("❌ Dados muito pequenos (< 8 bytes)");
                    return issues.join('\n');
                }

                // 2. Verificar primeiro box
                const firstBoxSize = view.getUint32(0);
                const firstBoxType = String.fromCharCode(
                    view.getUint8(4), view.getUint8(5), view.getUint8(6), view.getUint8(7)
                );

                if (label.includes('init')) {
                    // Init segment deve começar com ftyp
                    if (firstBoxType !== 'ftyp') {
                        issues.push(`❌ Init segment deve começar com 'ftyp', encontrado '${firstBoxType}'`);
                    } else {
                        issues.push("✓ Init segment começa com 'ftyp'");
                    }

                    // Verificar se tem moov
                    let hasMoov = false;
                    let offset = 0;
                    while (offset < data.byteLength - 8) {
                        const size = view.getUint32(offset);
                        const type = String.fromCharCode(
                            view.getUint8(offset + 4), view.getUint8(offset + 5),
                            view.getUint8(offset + 6), view.getUint8(offset + 7)
                        );
                        if (type === 'moov') hasMoov = true;
                        if (size < 8) break;
                        offset += size;
                    }

                    if (!hasMoov) {
                        issues.push("❌ Init segment não contém 'moov' box");
                    } else {
                        issues.push("✓ Init segment contém 'moov' box");
                    }

                } else if (label.includes('fragment')) {
                    // Fragment deve começar com moof ou styp
                    if (firstBoxType !== 'moof' && firstBoxType !== 'styp') {
                        issues.push(`❌ Fragment deve começar com 'moof' ou 'styp', encontrado '${firstBoxType}'`);
                    } else {
                        issues.push(`✓ Fragment começa com '${firstBoxType}'`);
                    }

                    // Verificar se tem mdat
                    let hasMdat = false;
                    let hasMoof = false;
                    let offset = 0;
                    while (offset < data.byteLength - 8) {
                        const size = view.getUint32(offset);
                        const type = String.fromCharCode(
                            view.getUint8(offset + 4), view.getUint8(offset + 5),
                            view.getUint8(offset + 6), view.getUint8(offset + 7)
                        );
                        if (type === 'mdat') hasMdat = true;
                        if (type === 'moof') hasMoof = true;
                        if (size < 8) break;
                        offset += size;
                    }

                    if (!hasMoof) {
                        issues.push("❌ Fragment não contém 'moof' box");
                    } else {
                        issues.push("✓ Fragment contém 'moof' box");
                    }

                    if (!hasMdat) {
                        issues.push("❌ Fragment não contém 'mdat' box");
                    } else {
                        issues.push("✓ Fragment contém 'mdat' box");
                    }
                }

                // 3. Verificar se o tamanho do primeiro box é válido
                if (firstBoxSize > data.byteLength) {
                    issues.push(`❌ Primeiro box declara tamanho ${firstBoxSize} mas dados têm ${data.byteLength} bytes`);
                }

                // 4. Verificar codec do MPD vs dados
                issues.push(`\nCodec do MPD: ${this.codec}`);
                issues.push(`Codec suportado: ${MediaSource.isTypeSupported(`video/mp4; codecs="${this.codec}"`) ? 'Sim' : 'Não'}`);

                return issues.join('\n');
            }
        }

        // ════════════════════════════════════════════════════════════════════
        // INSTÂNCIA E FUNÇÕES GLOBAIS
        // ════════════════════════════════════════════════════════════════════

        const player = new DebugDASHPlayer(document.getElementById('videoPlayer'), BaseUrl);

        function playVideo() {
            const videoName = document.getElementById('videoName').value.trim();
            if (!videoName) {
                alert('Digite o nome do vídeo');
                return;
            }
            player.play(videoName);
        }

        function stopVideo() {
            player.stop();
        }

        function analyzeBuffer() {
            if (player.lastInitData) {
                analyzeMP4Boxes(player.lastInitData, 'Último Init Segment');
            }
            if (player.lastFragmentData) {
                analyzeMP4Boxes(player.lastFragmentData, 'Último Fragment');
            }
        }

        async function testManualAppend() {
            log('info', '=== TESTE MANUAL DE APPEND ===');

            // Testar se MediaSource funciona com dados conhecidos
            const testVideo = document.createElement('video');
            const ms = new MediaSource();
            testVideo.src = URL.createObjectURL(ms);

            ms.addEventListener('sourceopen', async () => {
                try {
                    const mimeType = 'video/mp4; codecs="avc1.64001f"';
                    log('info', `Teste: criando SourceBuffer com ${mimeType}`);

                    if (!MediaSource.isTypeSupported(mimeType)) {
                        log('error', 'Codec não suportado neste navegador');
                        return;
                    }

                    const sb = ms.addSourceBuffer(mimeType);
                    log('success', 'SourceBuffer criado com sucesso');

                    // Tentar append com init real
                    if (player.lastInitData) {
                        log('info', 'Tentando append do último init segment...');
                        sb.appendBuffer(player.lastInitData);

                        sb.addEventListener('updateend', () => {
                            log('success', 'Append do init funcionou no teste!');

                            if (player.lastFragmentData) {
                                log('info', 'Tentando append do último fragment...');
                                sb.appendBuffer(player.lastFragmentData);

                                sb.addEventListener('updateend', () => {
                                    log('success', 'Append do fragment funcionou no teste!');
                                }, { once: true });

                                sb.addEventListener('error', (e) => {
                                    log('error', 'Erro no append do fragment no teste');
                                }, { once: true });
                            }
                        }, { once: true });

                        sb.addEventListener('error', (e) => {
                            log('error', 'Erro no append do init no teste');
                        }, { once: true });
                    }

                } catch (e) {
                    log('error', `Teste falhou: ${e.message}`);
                }
            });
        }

        // Atualizar status periodicamente
        setInterval(updateStatus, 1000);

        // Log inicial
        log('info', 'Debug Player inicializado');
        log('info', `Base URL: ${BaseUrl}`);
        log('info', `MediaSource suportado: ${!!window.MediaSource}`);

        // Verificar codecs comuns
        const testCodecs = [
            'video/mp4; codecs="avc1.64001f"',
            'video/mp4; codecs="avc1.640028"',
            'video/mp4; codecs="avc1.4d401f"',
            'video/mp4; codecs="avc1.42E01E"',
            'video/mp4'
        ];

        testCodecs.forEach(codec => {
            const supported = MediaSource.isTypeSupported(codec);
            log(supported ? 'success' : 'warning', `Codec ${codec}: ${supported ? 'suportado' : 'não suportado'}`);
        });
    </script>
</body>
</html>
<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DASH Player - DEBUG MODE</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Consolas', 'Monaco', monospace;
            background: #1a1a2e;
            color: #eee;
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
        }

        h1 {
            color: #00ff88;
            margin-bottom: 20px;
            font-size: 20px;
        }

        .input-group {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
        }

        input[type="text"] {
            flex: 1;
            padding: 10px;
            border: 2px solid #333;
            border-radius: 4px;
            background: #0f0f1a;
            color: #fff;
            font-family: inherit;
        }

        button {
            padding: 10px 20px;
            background: #00ff88;
            color: #000;
            border: none;
            border-radius: 4px;
            font-weight: bold;
            cursor: pointer;
        }

            button:hover {
                background: #00cc6a;
            }

            button.danger {
                background: #ff4444;
                color: #fff;
            }

        .main-content {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
        }

        .video-section {
            background: #0f0f1a;
            border-radius: 8px;
            padding: 15px;
            border: 1px solid #333;
        }

        video {
            width: 100%;
            height: auto;
            background: #000;
            border-radius: 4px;
        }

        .debug-section {
            background: #0f0f1a;
            border-radius: 8px;
            padding: 15px;
            border: 1px solid #333;
            max-height: 600px;
            overflow-y: auto;
        }

        .debug-title {
            color: #00ff88;
            margin-bottom: 10px;
            font-size: 14px;
            border-bottom: 1px solid #333;
            padding-bottom: 5px;
        }

        .log-entry {
            font-size: 11px;
            padding: 4px 8px;
            margin: 2px 0;
            border-radius: 2px;
            word-break: break-all;
        }

        .log-info {
            background: #1a3a5c;
            color: #7ec8e3;
        }

        .log-success {
            background: #1a3c1a;
            color: #7ee37e;
        }

        .log-warning {
            background: #3c3a1a;
            color: #e3e37e;
        }

        .log-error {
            background: #3c1a1a;
            color: #e37e7e;
        }

        .log-data {
            background: #2a1a3c;
            color: #c87ee3;
        }

        .status-panel {
            background: #0f0f1a;
            border-radius: 8px;
            padding: 15px;
            border: 1px solid #333;
            margin-top: 20px;
        }

        .status-grid {
            display: grid;
            grid-template-columns: repeat(5, 1fr);
            gap: 10px;
        }

        .status-item {
            background: #1a1a2e;
            padding: 10px;
            border-radius: 4px;
            text-align: center;
        }

        .status-label {
            font-size: 10px;
            color: #888;
            margin-bottom: 5px;
        }

        .status-value {
            font-size: 14px;
            color: #00ff88;
        }

        .controls {
            margin-top: 10px;
            display: flex;
            gap: 10px;
        }

            .controls button {
                flex: 1;
                padding: 8px;
                font-size: 12px;
            }
    </style>
</head>
<body>
    <div class="container">
        <h1>🎬 DASH Player - DEBUG MODE</h1>

        <div class="input-group">
            <input type="text" id="videoName" placeholder="Nome do vídeo" value="sample-3">
            <button onclick="playVideo()">▶ Play</button>
            <button class="danger" onclick="stopVideo()">⏹ Stop</button>
            <button onclick="clearLogs()">🗑 Clear Logs</button>
        </div>

        <div class="main-content">
            <div class="video-section">
                <div class="debug-title">📺 Video Player</div>
                <video id="videoPlayer" controls></video>
                <div class="controls">
                    <button onclick="player.video.currentTime -= 5">⏪ -5s</button>
                    <button onclick="player.video.currentTime += 5">⏩ +5s</button>
                </div>
            </div>

            <div class="debug-section" id="debugLog">
                <div class="debug-title">📋 Debug Log</div>
            </div>
        </div>

        <div class="status-panel">
            <div class="debug-title">📈 Status</div>
            <div class="status-grid">
                <div class="status-item">
                    <div class="status-label">MediaSource</div>
                    <div class="status-value" id="msState">-</div>
                </div>
                <div class="status-item">
                    <div class="status-label">SourceBuffer</div>
                    <div class="status-value" id="sbState">-</div>
                </div>
                <div class="status-item">
                    <div class="status-label">Fragment</div>
                    <div class="status-value" id="fragNum">-</div>
                </div>
                <div class="status-item">
                    <div class="status-label">Buffer Range</div>
                    <div class="status-value" id="bufLen">-</div>
                </div>
                <div class="status-item">
                    <div class="status-label">Video Time</div>
                    <div class="status-value" id="videoTime">-</div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // ════════════════════════════════════════════════════════════════════
        // CONFIGURAÇÃO
        // ════════════════════════════════════════════════════════════════════
        const BaseUrl = "http://localhost:1234/api";

        // ════════════════════════════════════════════════════════════════════
        // FUNÇÕES DE LOG
        // ════════════════════════════════════════════════════════════════════
        function log(type, message, data = null) {
            const timestamp = new Date().toISOString().substr(11, 12);
            const logDiv = document.getElementById('debugLog');
            const entryDiv = document.createElement('div');
            entryDiv.className = `log-entry log-${type}`;

            let content = `[${timestamp}] ${message}`;
            if (data) {
                if (typeof data === 'object') {
                    content += '\n' + JSON.stringify(data, null, 2);
                } else {
                    content += ` | ${data}`;
                }
            }

            entryDiv.textContent = content;
            logDiv.appendChild(entryDiv);
            logDiv.scrollTop = logDiv.scrollHeight;
            console.log(`[${type.toUpperCase()}]`, message, data || '');
        }

        function clearLogs() {
            document.getElementById('debugLog').innerHTML = '<div class="debug-title">📋 Debug Log</div>';
        }

        // ════════════════════════════════════════════════════════════════════
        // DASH PLAYER CLASS
        // ════════════════════════════════════════════════════════════════════
        class DASHPlayer {
            constructor(videoElement, baseUrl) {
                this.video = videoElement;
                this.baseUrl = baseUrl;
                this.mediaSource = null;
                this.sourceBuffer = null;
                this.isPlaying = false;
                this.currentFragment = 0;
                this.totalFragments = 0;
                this.codec = '';
                this.videoName = '';
                this.fragmentQueue = [];
                this.isAppending = false;
                this.hasStartedPlayback = false;
            }

            async play(videoName) {
                this.stop();
                this.videoName = videoName;
                this.isPlaying = true;
                this.currentFragment = 0;
                this.hasStartedPlayback = false;

                try {
                    log('info', `Iniciando reprodução: ${videoName}`);

                    // 1. Buscar e parsear MPD
                    const mpdInfo = await this.fetchMPD();
                    log('success', 'MPD carregado', mpdInfo);

                    // 2. Configurar MediaSource
                    await this.setupMediaSource(mpdInfo.codec);
                    log('success', 'MediaSource configurado');

                    // 3. Buscar init segment
                    const initData = await this.fetchInitSegment();
                    await this.appendBuffer(initData, 'init');
                    log('success', 'Init segment carregado');

                    // 4. Começar a carregar fragmentos
                    this.loadFragments();

                } catch (error) {
                    log('error', `Erro: ${error.message}`);
                    console.error(error);
                }
            }

            stop() {
                this.isPlaying = false;
                this.fragmentQueue = [];
                this.hasStartedPlayback = false;

                if (this.mediaSource && this.mediaSource.readyState === 'open') {
                    try {
                        this.mediaSource.endOfStream();
                    } catch (e) { }
                }

                this.video.pause();
                this.video.src = '';
                this.mediaSource = null;
                this.sourceBuffer = null;
                log('info', 'Player parado');
            }

            async fetchMPD() {
                const url = `${this.baseUrl}/${this.videoName}.mpd`;
                log('info', `Buscando MPD: ${url}`);

                const response = await fetch(url);
                if (!response.ok) throw new Error(`MPD não encontrado: ${response.status}`);

                const text = await response.text();
                return this.parseMPD(text);
            }

            parseMPD(xmlText) {
                const parser = new DOMParser();
                const xml = parser.parseFromString(xmlText, 'text/xml');

                const adaptationSet = xml.querySelector('AdaptationSet');
                const codec = adaptationSet?.getAttribute('codecs') || 'avc1.64001f';
                this.codec = codec;

                const mpd = xml.querySelector('MPD');
                const durationStr = mpd?.getAttribute('mediaPresentationDuration') || 'PT0S';
                const totalSeconds = this.parseDuration(durationStr);

                const segmentTemplate = xml.querySelector('SegmentTemplate');
                const timescale = parseInt(segmentTemplate?.getAttribute('timescale') || '90000');
                const duration = parseInt(segmentTemplate?.getAttribute('duration') || '180000');
                const fragmentDuration = duration / timescale;

                this.totalFragments = Math.ceil(totalSeconds / fragmentDuration);

                return {
                    codec,
                    totalSeconds,
                    fragmentDuration,
                    totalFragments: this.totalFragments,
                    timescale
                };
            }

            parseDuration(duration) {
                const matches = duration.match(/PT(?:(\d+)H)?(?:(\d+)M)?(?:(\d+(?:\.\d+)?)S)?/);
                const hours = parseInt(matches?.[1] || '0');
                const minutes = parseInt(matches?.[2] || '0');
                const seconds = parseFloat(matches?.[3] || '0');
                return hours * 3600 + minutes * 60 + seconds;
            }

            async setupMediaSource(codec) {
                return new Promise((resolve, reject) => {
                    this.mediaSource = new MediaSource();
                    this.video.src = URL.createObjectURL(this.mediaSource);

                    this.mediaSource.addEventListener('sourceopen', () => {
                        try {
                            let mimeType = `video/mp4; codecs="${codec}"`;

                            // Tentar codec original, senão fallback
                            if (!MediaSource.isTypeSupported(mimeType)) {
                                const fallbacks = [
                                    'video/mp4; codecs="avc1.64001f"',
                                    'video/mp4; codecs="avc1.640028"',
                                    'video/mp4; codecs="avc1.4d401f"',
                                    'video/mp4'
                                ];

                                for (const fb of fallbacks) {
                                    if (MediaSource.isTypeSupported(fb)) {
                                        mimeType = fb;
                                        log('warning', `Usando codec fallback: ${fb}`);
                                        break;
                                    }
                                }
                            }

                            this.sourceBuffer = this.mediaSource.addSourceBuffer(mimeType);
                            this.sourceBuffer.mode = 'segments';

                            // Event listeners
                            this.sourceBuffer.addEventListener('updateend', () => this.onUpdateEnd());
                            this.sourceBuffer.addEventListener('error', (e) => log('error', 'SourceBuffer error', e));

                            resolve();
                        } catch (error) {
                            reject(error);
                        }
                    });

                    this.mediaSource.addEventListener('error', () => reject(new Error('MediaSource error')));
                });
            }

            async fetchInitSegment() {
                const url = `${this.baseUrl}/init.mp4`;
                log('info', `Buscando init: ${url}`);

                const response = await fetch(url);
                if (!response.ok) throw new Error(`Init segment error: ${response.status}`);

                const data = await response.arrayBuffer();
                log('success', `Init recebido: ${data.byteLength} bytes`);
                return data;
            }

            async fetchFragment(number) {
                const url = `${this.baseUrl}/fragment_${number}.m4s`;
                log('info', `Buscando fragment ${number}: ${url}`);

                const response = await fetch(url);
                if (!response.ok) {
                    if (response.status === 404 || response.status === 500) {
                        return null; // Fim dos fragmentos
                    }
                    throw new Error(`Fragment ${number} error: ${response.status}`);
                }

                const data = await response.arrayBuffer();
                log('success', `Fragment ${number}: ${data.byteLength} bytes`);
                return data;
            }

            async loadFragments() {
                while (this.isPlaying && this.currentFragment < this.totalFragments) {
                    try {
                        const fragment = await this.fetchFragment(this.currentFragment);

                        if (!fragment) {
                            log('info', 'Fim dos fragmentos');
                            break;
                        }

                        await this.appendBuffer(fragment, `fragment_${this.currentFragment}`);

                        // ═══════════════════════════════════════════════════════════
                        // CORREÇÃO: Iniciar playback após primeiro fragmento
                        // ═══════════════════════════════════════════════════════════
                        if (!this.hasStartedPlayback && this.currentFragment === 0) {
                            this.startPlayback();
                        }

                        this.currentFragment++;
                        updateStatus();

                    } catch (error) {
                        log('error', `Erro no fragment ${this.currentFragment}: ${error.message}`);
                        break;
                    }
                }

                // Finalizar stream
                if (this.mediaSource && this.mediaSource.readyState === 'open') {
                    try {
                        // Aguardar buffer terminar de atualizar
                        await this.waitForBuffer();
                        this.mediaSource.endOfStream();
                        log('success', 'Stream finalizado');
                    } catch (e) {
                        log('warning', `Erro ao finalizar: ${e.message}`);
                    }
                }
            }

            startPlayback() {
                this.hasStartedPlayback = true;

                // Aguardar um pouco para ter dados no buffer
                const tryPlay = () => {
                    if (this.video.readyState >= 2) { // HAVE_CURRENT_DATA ou mais
                        this.video.play()
                            .then(() => log('success', '▶ Playback iniciado automaticamente'))
                            .catch(e => log('warning', `Autoplay bloqueado: ${e.message}. Clique no vídeo.`));
                    } else {
                        // Tentar novamente em 100ms
                        setTimeout(tryPlay, 100);
                    }
                };

                tryPlay();
            }

            appendBuffer(data, label) {
                return new Promise((resolve, reject) => {
                    if (!this.sourceBuffer) {
                        reject(new Error('SourceBuffer não existe'));
                        return;
                    }

                    if (this.mediaSource.readyState !== 'open') {
                        reject(new Error(`MediaSource não está aberto: ${this.mediaSource.readyState}`));
                        return;
                    }

                    // Adicionar à fila
                    this.fragmentQueue.push({ data, label, resolve, reject });
                    this.processQueue();
                });
            }

            processQueue() {
                if (this.isAppending || this.fragmentQueue.length === 0) {
                    return;
                }

                if (this.sourceBuffer.updating) {
                    return;
                }

                this.isAppending = true;
                const { data, label, resolve, reject } = this.fragmentQueue.shift();

                try {
                    this.sourceBuffer.appendBuffer(data);
                    this._currentResolve = resolve;
                    this._currentReject = reject;
                    this._currentLabel = label;
                } catch (error) {
                    this.isAppending = false;
                    log('error', `Erro ao appendar ${label}: ${error.message}`);
                    reject(error);
                    this.processQueue();
                }
            }

            onUpdateEnd() {
                this.isAppending = false;

                if (this._currentResolve) {
                    this._currentResolve();
                    this._currentResolve = null;
                    this._currentReject = null;
                }

                // Processar próximo item da fila
                this.processQueue();
            }

            waitForBuffer() {
                return new Promise((resolve) => {
                    if (!this.sourceBuffer || !this.sourceBuffer.updating) {
                        resolve();
                    } else {
                        this.sourceBuffer.addEventListener('updateend', resolve, { once: true });
                    }
                });
            }
        }

        // ════════════════════════════════════════════════════════════════════
        // INSTÂNCIA E FUNÇÕES GLOBAIS
        // ════════════════════════════════════════════════════════════════════
        const player = new DASHPlayer(document.getElementById('videoPlayer'), BaseUrl);

        function playVideo() {
            const videoName = document.getElementById('videoName').value.trim();
            if (!videoName) {
                alert('Digite o nome do vídeo');
                return;
            }
            player.play(videoName);
        }

        function stopVideo() {
            player.stop();
        }

        function updateStatus() {
            document.getElementById('msState').textContent =
                player.mediaSource ? player.mediaSource.readyState : '-';

            document.getElementById('sbState').textContent =
                player.sourceBuffer ? (player.sourceBuffer.updating ? 'updating' : 'ready') : '-';

            document.getElementById('fragNum').textContent =
                `${player.currentFragment}/${player.totalFragments}`;

            if (player.sourceBuffer && player.sourceBuffer.buffered.length > 0) {
                const start = player.sourceBuffer.buffered.start(0).toFixed(2);
                const end = player.sourceBuffer.buffered.end(0).toFixed(2);
                document.getElementById('bufLen').textContent = `${start}s - ${end}s`;
            } else {
                document.getElementById('bufLen').textContent = '-';
            }

            document.getElementById('videoTime').textContent =
                player.video.currentTime.toFixed(2) + 's';
        }

        // Atualizar status periodicamente
        setInterval(updateStatus, 500);

        // Log inicial
        log('info', 'DASH Player inicializado');
        log('info', `Base URL: ${BaseUrl}`);
        log('info', `MediaSource suportado: ${!!window.MediaSource}`);
    </script>
</body>
</html>
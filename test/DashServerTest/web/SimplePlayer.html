<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DASH Player - DEBUG MODE</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Consolas', 'Monaco', monospace;
            background: #1a1a2e;
            color: #eee;
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
        }

        h1 {
            color: #00ff88;
            margin-bottom: 20px;
            font-size: 20px;
        }

        .input-group {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
        }

        input[type="text"] {
            flex: 1;
            padding: 10px;
            border: 2px solid #333;
            border-radius: 4px;
            background: #0f0f1a;
            color: #fff;
            font-family: inherit;
        }

        button {
            padding: 10px 20px;
            background: #00ff88;
            color: #000;
            border: none;
            border-radius: 4px;
            font-weight: bold;
            cursor: pointer;
        }

            button:hover {
                background: #00cc6a;
            }

            button.danger {
                background: #ff4444;
                color: #fff;
            }

        .main-content {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
        }

        .video-section {
            background: #0f0f1a;
            border-radius: 8px;
            padding: 15px;
            border: 1px solid #333;
        }

        video {
            width: 100%;
            height: auto;
            background: #000;
            border-radius: 4px;
        }

        .debug-section {
            background: #0f0f1a;
            border-radius: 8px;
            padding: 15px;
            border: 1px solid #333;
            max-height: 600px;
            overflow-y: auto;
        }

        .debug-title {
            color: #00ff88;
            margin-bottom: 10px;
            font-size: 14px;
            border-bottom: 1px solid #333;
            padding-bottom: 5px;
        }

        .log-entry {
            font-size: 11px;
            padding: 4px 8px;
            margin: 2px 0;
            border-radius: 2px;
            word-break: break-all;
        }

        .log-info {
            background: #1a3a5c;
            color: #7ec8e3;
        }

        .log-success {
            background: #1a3c1a;
            color: #7ee37e;
        }

        .log-warning {
            background: #3c3a1a;
            color: #e3e37e;
        }

        .log-error {
            background: #3c1a1a;
            color: #e37e7e;
        }

        .log-data {
            background: #2a1a3c;
            color: #c87ee3;
        }

        .hex-dump {
            font-size: 10px;
            background: #000;
            padding: 10px;
            border-radius: 4px;
            overflow-x: auto;
            white-space: pre;
            color: #888;
            max-height: 200px;
            overflow-y: auto;
        }

        .box-info {
            display: inline-block;
            background: #333;
            padding: 2px 6px;
            border-radius: 3px;
            margin: 2px;
            font-size: 10px;
        }

        .status-panel {
            background: #0f0f1a;
            border-radius: 8px;
            padding: 15px;
            border: 1px solid #333;
            margin-top: 20px;
        }

        .status-grid {
            display: grid;
            grid-template-columns: repeat(5, 1fr);
            gap: 10px;
        }

        .status-item {
            background: #1a1a2e;
            padding: 10px;
            border-radius: 4px;
            text-align: center;
        }

        .status-label {
            font-size: 10px;
            color: #888;
            margin-bottom: 5px;
        }

        .status-value {
            font-size: 14px;
            color: #00ff88;
        }

        .error-details {
            background: #2a0a0a;
            border: 1px solid #ff4444;
            border-radius: 4px;
            padding: 15px;
            margin-top: 10px;
        }

            .error-details h3 {
                color: #ff4444;
                margin-bottom: 10px;
            }

            .error-details pre {
                font-size: 11px;
                white-space: pre-wrap;
                color: #ffaaaa;
            }

        .controls {
            margin-top: 10px;
            display: flex;
            gap: 10px;
        }

            .controls button {
                flex: 1;
                padding: 8px;
                font-size: 12px;
            }
    </style>
</head>
<body>
    <div class="container">
        <h1>DASH Player - DEBUG MODE</h1>

        <div class="input-group">
            <input type="text" id="videoName" placeholder="Nome do vídeo" value="sample-3">
            <button onclick="playVideo()">Play</button>
            <button class="danger" onclick="stopVideo()">Stop</button>
            <button onclick="clearLogs()">Clear Logs</button>
            <button onclick="downloadLogs()">Export Logs</button>
        </div>

        <div class="main-content">
            <div class="video-section">
                <div class="debug-title">Video Player</div>
                <video id="videoPlayer" controls></video>
                <div class="controls">
                    <button onclick="analyzeBuffer()">Analyze Buffer</button>
                    <button onclick="player.video.currentTime -= 5">-5s</button>
                    <button onclick="player.video.currentTime += 5">+5s</button>
                </div>
            </div>

            <div class="debug-section" id="debugLog">
                <div class="debug-title">Debug Log</div>
            </div>
        </div>

        <div class="status-panel">
            <div class="debug-title">Status</div>
            <div class="status-grid">
                <div class="status-item">
                    <div class="status-label">MediaSource State</div>
                    <div class="status-value" id="msState">-</div>
                </div>
                <div class="status-item">
                    <div class="status-label">SourceBuffer State</div>
                    <div class="status-value" id="sbState">-</div>
                </div>
                <div class="status-item">
                    <div class="status-label">Current Fragment</div>
                    <div class="status-value" id="fragNum">-</div>
                </div>
                <div class="status-item">
                    <div class="status-label">Buffer Length</div>
                    <div class="status-value" id="bufLen">-</div>
                </div>
                <div class="status-item">
                    <div class="status-label">Video Time</div>
                    <div class="status-value" id="videoTime">-</div>
                </div>
            </div>
        </div>

        <div id="errorDetails" class="error-details" style="display: none;">
            <h3>Error Details</h3>
            <pre id="errorContent"></pre>
        </div>

        <div class="status-panel">
            <div class="debug-title">Last Segment Analysis</div>
            <div id="segmentAnalysis">Nenhum segmento analisado ainda.</div>
        </div>
    </div>

    <script>
        // ════════════════════════════════════════════════════════════════════
        // CONFIGURAÇÃO
        // ════════════════════════════════════════════════════════════════════
        const BaseUrl = "http://localhost:1234/api";
        const logs = [];

        // ════════════════════════════════════════════════════════════════════
        // FUNÇÕES DE LOG
        // ════════════════════════════════════════════════════════════════════
        function log(type, message, data = null) {
            const timestamp = new Date().toISOString().substr(11, 12);
            const entry = { timestamp, type, message, data };
            logs.push(entry);

            const logDiv = document.getElementById('debugLog');
            const entryDiv = document.createElement('div');
            entryDiv.className = `log-entry log-${type}`;

            let content = `[${timestamp}] ${message}`;
            if (data) {
                if (typeof data === 'object') {
                    content += '\n' + JSON.stringify(data, null, 2);
                } else {
                    content += ` | ${data}`;
                }
            }

            entryDiv.textContent = content;
            logDiv.appendChild(entryDiv);
            logDiv.scrollTop = logDiv.scrollHeight;
            console.log(`[${type.toUpperCase()}]`, message, data || '');
        }

        function clearLogs() {
            logs.length = 0;
            document.getElementById('debugLog').innerHTML = '<div class="debug-title">📋 Debug Log</div>';
            document.getElementById('errorDetails').style.display = 'none';
        }

        function downloadLogs() {
            const content = logs.map(l =>
                `[${l.timestamp}] [${l.type}] ${l.message}${l.data ? '\n' + JSON.stringify(l.data, null, 2) : ''}`
            ).join('\n\n');

            const blob = new Blob([content], { type: 'text/plain' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `dash-debug-${Date.now()}.log`;
            a.click();
        }

        function showError(title, details) {
            const errorDiv = document.getElementById('errorDetails');
            const contentDiv = document.getElementById('errorContent');

            errorDiv.style.display = 'block';
            contentDiv.textContent = `${title}\n\n${details}`;

            log('error', title, details);
        }

        function updateStatus() {
            document.getElementById('msState').textContent =
                player.mediaSource ? player.mediaSource.readyState : '-';
            document.getElementById('sbState').textContent =
                player.sourceBuffer ? (player.sourceBuffer.updating ? 'updating' : 'ready') : '-';
            document.getElementById('fragNum').textContent =
                `${player.currentFragment}/${player.totalFragments}`;

            if (player.sourceBuffer && player.sourceBuffer.buffered.length > 0) {
                const start = player.sourceBuffer.buffered.start(0).toFixed(2);
                const end = player.sourceBuffer.buffered.end(0).toFixed(2);
                document.getElementById('bufLen').textContent = `${start}s - ${end}s`;
            } else {
                document.getElementById('bufLen').textContent = '-';
            }

            document.getElementById('videoTime').textContent =
                player.video.currentTime.toFixed(2) + 's';
        }

        // ════════════════════════════════════════════════════════════════════
        // ANÁLISE DE MP4
        // ════════════════════════════════════════════════════════════════════
        function hexDump(buffer, offset, length) {
            const bytes = new Uint8Array(buffer, offset, length);
            let result = '';
            for (let i = 0; i < bytes.length; i += 16) {
                const hex = Array.from(bytes.slice(i, i + 16))
                    .map(b => b.toString(16).padStart(2, '0'))
                    .join(' ');
                const ascii = Array.from(bytes.slice(i, i + 16))
                    .map(b => (b >= 32 && b <= 126) ? String.fromCharCode(b) : '.')
                    .join('');
                result += `${i.toString(16).padStart(4, '0')}  ${hex.padEnd(48)}  ${ascii}\n`;
            }
            return result;
        }

        function analyzeMP4Boxes(data, label) {
            const view = new DataView(data);
            const boxes = [];
            let offset = 0;

            log('data', `Analisando ${label}: ${data.byteLength} bytes`);

            while (offset < data.byteLength - 8) {
                try {
                    let size = view.getUint32(offset);
                    const type = String.fromCharCode(
                        view.getUint8(offset + 4),
                        view.getUint8(offset + 5),
                        view.getUint8(offset + 6),
                        view.getUint8(offset + 7)
                    );

                    let headerSize = 8;
                    if (size === 1 && offset + 16 <= data.byteLength) {
                        const highBits = view.getUint32(offset + 8);
                        const lowBits = view.getUint32(offset + 12);
                        size = highBits * 0x100000000 + lowBits;
                        headerSize = 16;
                    }

                    if (size === 0) {
                        size = data.byteLength - offset;
                    }

                    if (size < 8 || offset + size > data.byteLength) {
                        log('warning', `Box inválido em offset ${offset}: size=${size}, remaining=${data.byteLength - offset}`);
                        break;
                    }

                    const box = { type, size, offset, headerSize };
                    boxes.push(box);
                    log('info', `Box encontrado: '${type}' size=${size} offset=${offset}`);

                    // Análise específica por tipo
                    if (type === 'ftyp') {
                        analyzeFtyp(view, offset, size);
                    } else if (type === 'moov') {
                        log('success', 'moov box encontrado (initialization segment OK)');
                        analyzeContainerBox(view, offset + headerSize, size - headerSize, 1);
                    } else if (type === 'moof') {
                        log('success', 'moof box encontrado (fragment header)');
                        analyzeContainerBox(view, offset + headerSize, size - headerSize, 1);
                    } else if (type === 'mdat') {
                        log('success', `mdat box encontrado: ${size - headerSize} bytes de dados de vídeo`);
                    }

                    offset += size;
                } catch (e) {
                    log('error', `Erro ao analisar box em offset ${offset}: ${e.message}`);
                    break;
                }
            }

            // Mostrar análise visual
            const analysisDiv = document.getElementById('segmentAnalysis');
            analysisDiv.innerHTML = `
                    <div style="margin-bottom: 10px;"><strong>${label}</strong> (${data.byteLength} bytes)</div>
                    <div>
                        ${boxes.map(b => `<span class="box-info">${b.type} (${b.size}B)</span>`).join(' ')}
                    </div>
                    <div class="hex-dump">${hexDump(data, 0, Math.min(256, data.byteLength))}</div>
                `;

            return boxes;
        }

        function analyzeFtyp(view, offset, size) {
            try {
                const majorBrand = String.fromCharCode(
                    view.getUint8(offset + 8),
                    view.getUint8(offset + 9),
                    view.getUint8(offset + 10),
                    view.getUint8(offset + 11)
                );
                const minorVersion = view.getUint32(offset + 12);

                log('info', `ftyp: majorBrand='${majorBrand}', minorVersion=${minorVersion}`);

                const brands = [];
                for (let i = 16; i < size; i += 4) {
                    const brand = String.fromCharCode(
                        view.getUint8(offset + i),
                        view.getUint8(offset + i + 1),
                        view.getUint8(offset + i + 2),
                        view.getUint8(offset + i + 3)
                    );
                    if (brand.trim()) brands.push(brand);
                }
                log('info', `ftyp: compatibleBrands=[${brands.join(', ')}]`);
            } catch (e) {
                log('warning', `Erro ao analisar ftyp: ${e.message}`);
            }
        }

        function analyzeContainerBox(view, offset, size, depth) {
            const indent = '  '.repeat(depth);
            let pos = offset;
            const end = offset + size;

            while (pos < end - 8) {
                try {
                    let boxSize = view.getUint32(pos);
                    const boxType = String.fromCharCode(
                        view.getUint8(pos + 4),
                        view.getUint8(pos + 5),
                        view.getUint8(pos + 6),
                        view.getUint8(pos + 7)
                    );

                    if (boxSize === 0) boxSize = end - pos;
                    if (boxSize < 8 || pos + boxSize > end) break;

                    log('info', `${indent}├─ ${boxType} (${boxSize} bytes)`);

                    // Análise específica de boxes importantes
                    if (boxType === 'tfdt') {
                        analyzeTfdt(view, pos);
                    } else if (boxType === 'trun') {
                        analyzeTrun(view, pos, boxSize);
                    } else if (boxType === 'mfhd') {
                        analyzeMfhd(view, pos);
                    } else if (boxType === 'tfhd') {
                        analyzeTfhd(view, pos);
                    } else if (boxType === 'mvhd') {
                        analyzeMvhd(view, pos);
                    } else if (boxType === 'tkhd') {
                        analyzeTkhd(view, pos);
                    } else if (boxType === 'mdhd') {
                        analyzeMdhd(view, pos);
                    } else if (boxType === 'hdlr') {
                        analyzeHdlr(view, pos, boxSize);
                    } else if (boxType === 'stsd') {
                        analyzeStsd(view, pos, boxSize);
                    } else if (boxType === 'avcC') {
                        analyzeAvcC(view, pos, boxSize);
                    } else if (boxType === 'trex') {
                        analyzeTrex(view, pos);
                    }

                    // Recursão para containers conhecidos
                    const containers = ['moov', 'trak', 'mdia', 'minf', 'stbl', 'mvex', 'moof', 'traf', 'edts', 'dinf', 'avc1', 'avc3'];
                    if (containers.includes(boxType)) {
                        analyzeContainerBox(view, pos + 8, boxSize - 8, depth + 1);
                    }

                    pos += boxSize;
                } catch (e) {
                    break;
                }
            }
        }

        function analyzeMfhd(view, offset) {
            try {
                const sequenceNumber = view.getUint32(offset + 12);
                log('data', `    mfhd: sequenceNumber=${sequenceNumber}`);
            } catch (e) { }
        }

        function analyzeTfhd(view, offset) {
            try {
                const flags = (view.getUint8(offset + 9) << 16) |
                    (view.getUint8(offset + 10) << 8) |
                    view.getUint8(offset + 11);
                const trackId = view.getUint32(offset + 12);

                let flagsStr = [];
                if (flags & 0x000001) flagsStr.push('base-data-offset');
                if (flags & 0x000002) flagsStr.push('sample-description-index');
                if (flags & 0x000008) flagsStr.push('default-sample-duration');
                if (flags & 0x000010) flagsStr.push('default-sample-size');
                if (flags & 0x000020) flagsStr.push('default-sample-flags');
                if (flags & 0x010000) flagsStr.push('duration-is-empty');
                if (flags & 0x020000) flagsStr.push('default-base-is-moof');

                log('data', `    tfhd: trackId=${trackId}, flags=0x${flags.toString(16)} [${flagsStr.join(', ')}]`);
            } catch (e) { }
        }

        function analyzeTfdt(view, offset) {
            try {
                const version = view.getUint8(offset + 8);
                let baseMediaDecodeTime;
                if (version === 1) {
                    const high = view.getUint32(offset + 12);
                    const low = view.getUint32(offset + 16);
                    baseMediaDecodeTime = high * 0x100000000 + low;
                } else {
                    baseMediaDecodeTime = view.getUint32(offset + 12);
                }
                log('data', `    tfdt: version=${version}, baseMediaDecodeTime=${baseMediaDecodeTime}`);
            } catch (e) { }
        }

        function analyzeTrun(view, offset, size) {
            try {
                const version = view.getUint8(offset + 8);
                const flags = (view.getUint8(offset + 9) << 16) |
                    (view.getUint8(offset + 10) << 8) |
                    view.getUint8(offset + 11);
                const sampleCount = view.getUint32(offset + 12);

                let flagsStr = [];
                if (flags & 0x001) flagsStr.push('data-offset');
                if (flags & 0x004) flagsStr.push('first-sample-flags');
                if (flags & 0x100) flagsStr.push('sample-duration');
                if (flags & 0x200) flagsStr.push('sample-size');
                if (flags & 0x400) flagsStr.push('sample-flags');
                if (flags & 0x800) flagsStr.push('sample-composition-time');

                log('data', `    trun: version=${version}, flags=0x${flags.toString(16)} [${flagsStr.join(', ')}], sampleCount=${sampleCount}`);

                // Mostrar alguns samples se houver
                if (sampleCount > 0 && sampleCount <= 5) {
                    let sampleOffset = 16; // Após header + sample_count
                    if (flags & 0x001) sampleOffset += 4; // data_offset
                    if (flags & 0x004) sampleOffset += 4; // first_sample_flags

                    for (let i = 0; i < sampleCount && (offset + sampleOffset + 8) < (offset + size); i++) {
                        let sampleInfo = `      sample[${i}]:`;
                        if (flags & 0x100) {
                            sampleInfo += ` duration=${view.getUint32(offset + sampleOffset)}`;
                            sampleOffset += 4;
                        }
                        if (flags & 0x200) {
                            sampleInfo += ` size=${view.getUint32(offset + sampleOffset)}`;
                            sampleOffset += 4;
                        }
                        log('data', sampleInfo);
                    }
                }
            } catch (e) { }
        }

        function analyzeMvhd(view, offset) {
            try {
                const version = view.getUint8(offset + 8);
                let timescale, duration;
                if (version === 1) {
                    timescale = view.getUint32(offset + 28);
                    duration = view.getUint32(offset + 36); // Simplified, ignoring high bits
                } else {
                    timescale = view.getUint32(offset + 20);
                    duration = view.getUint32(offset + 24);
                }
                log('data', `    mvhd: version=${version}, timescale=${timescale}, duration=${duration}`);
            } catch (e) { }
        }

        function analyzeTkhd(view, offset) {
            try {
                const version = view.getUint8(offset + 8);
                const flags = (view.getUint8(offset + 9) << 16) |
                    (view.getUint8(offset + 10) << 8) |
                    view.getUint8(offset + 11);
                let trackId, width, height;
                if (version === 1) {
                    trackId = view.getUint32(offset + 28);
                    width = view.getUint32(offset + 92) / 65536;
                    height = view.getUint32(offset + 96) / 65536;
                } else {
                    trackId = view.getUint32(offset + 20);
                    width = view.getUint32(offset + 84) / 65536;
                    height = view.getUint32(offset + 88) / 65536;
                }
                log('data', `    tkhd: trackId=${trackId}, flags=0x${flags.toString(16)}, ${width}x${height}`);
            } catch (e) { }
        }

        function analyzeMdhd(view, offset) {
            try {
                const version = view.getUint8(offset + 8);
                let timescale;
                if (version === 1) {
                    timescale = view.getUint32(offset + 28);
                } else {
                    timescale = view.getUint32(offset + 20);
                }
                log('data', `    mdhd: version=${version}, timescale=${timescale}`);
            } catch (e) { }
        }

        function analyzeHdlr(view, offset, size) {
            try {
                const handlerType = String.fromCharCode(
                    view.getUint8(offset + 16),
                    view.getUint8(offset + 17),
                    view.getUint8(offset + 18),
                    view.getUint8(offset + 19)
                );
                log('data', `    hdlr: handlerType='${handlerType}'`);
            } catch (e) { }
        }

        function analyzeStsd(view, offset, size) {
            try {
                const entryCount = view.getUint32(offset + 12);
                log('data', `    stsd: entryCount=${entryCount}`);
            } catch (e) { }
        }

        function analyzeAvcC(view, offset, size) {
            try {
                const configVersion = view.getUint8(offset + 8);
                const profileIndication = view.getUint8(offset + 9);
                const profileCompatibility = view.getUint8(offset + 10);
                const levelIndication = view.getUint8(offset + 11);
                const lengthSizeMinusOne = view.getUint8(offset + 12) & 0x03;

                log('data', `    avcC: profile=${profileIndication}, level=${levelIndication / 10}, lengthSize=${lengthSizeMinusOne + 1}`);
            } catch (e) { }
        }

        function analyzeTrex(view, offset) {
            try {
                const trackId = view.getUint32(offset + 12);
                const defaultSampleDescriptionIndex = view.getUint32(offset + 16);
                const defaultSampleDuration = view.getUint32(offset + 20);
                const defaultSampleSize = view.getUint32(offset + 24);
                const defaultSampleFlags = view.getUint32(offset + 28);

                log('data', `    trex: trackId=${trackId}, defaultDuration=${defaultSampleDuration}, defaultSize=${defaultSampleSize}`);
            } catch (e) { }
        }

        // ════════════════════════════════════════════════════════════════════
        // DASH PLAYER CLASS
        // ════════════════════════════════════════════════════════════════════
        class DASHPlayer {
            constructor(videoElement, baseUrl) {
                this.video = videoElement;
                this.baseUrl = baseUrl;
                this.mediaSource = null;
                this.sourceBuffer = null;
                this.isPlaying = false;
                this.currentFragment = 0;
                this.totalFragments = 0;
                this.codec = '';
                this.videoName = '';
                this.fragmentQueue = [];
                this.isAppending = false;
                this.hasStartedPlayback = false;
                this.lastInitData = null;
                this.lastFragmentData = null;
            }

            async play(videoName) {
                this.stop();
                this.videoName = videoName;
                this.isPlaying = true;
                this.currentFragment = 0;
                this.hasStartedPlayback = false;

                try {
                    log('info', `═══════════════════════════════════════════════════`);
                    log('info', `Iniciando reprodução: ${videoName}`);
                    log('info', `═══════════════════════════════════════════════════`);

                    // 1. Buscar e parsear MPD
                    const mpdInfo = await this.fetchMPD();
                    log('success', 'MPD carregado', mpdInfo);

                    // 2. Configurar MediaSource
                    await this.setupMediaSource(mpdInfo.codec);
                    log('success', 'MediaSource configurado');

                    // 3. Buscar init segment
                    const initData = await this.fetchInitSegment();
                    this.lastInitData = initData;
                    analyzeMP4Boxes(initData, 'Init Segment');
                    await this.appendBuffer(initData, 'init');
                    log('success', 'Init segment appendado');

                    // 4. Começar a carregar fragmentos
                    this.loadFragments();

                } catch (error) {
                    showError('Erro ao iniciar reprodução', error.message + '\n' + error.stack);
                }
            }

            stop() {
                this.isPlaying = false;
                this.fragmentQueue = [];
                this.hasStartedPlayback = false;

                if (this.mediaSource && this.mediaSource.readyState === 'open') {
                    try {
                        this.mediaSource.endOfStream();
                    } catch (e) { }
                }

                this.video.pause();
                this.video.src = '';
                this.mediaSource = null;
                this.sourceBuffer = null;
                log('info', 'Player parado');
                updateStatus();
            }

            async fetchMPD() {
                const url = `${this.baseUrl}/${this.videoName}.mpd`;
                log('info', `Fetching MPD: ${url}`);

                const response = await fetch(url);
                if (!response.ok) throw new Error(`MPD não encontrado: ${response.status}`);

                const text = await response.text();
                log('data', 'MPD Content:', text.substring(0, 500));
                return this.parseMPD(text);
            }

            parseMPD(xmlText) {
                const parser = new DOMParser();
                const xml = parser.parseFromString(xmlText, 'text/xml');

                const parseError = xml.querySelector('parsererror');
                if (parseError) {
                    throw new Error(`XML Parse Error: ${parseError.textContent}`);
                }

                const adaptationSet = xml.querySelector('AdaptationSet');
                const codec = adaptationSet?.getAttribute('codecs') || 'avc1.64001f';
                this.codec = codec;

                const mpd = xml.querySelector('MPD');
                const durationStr = mpd?.getAttribute('mediaPresentationDuration') || 'PT0S';
                const totalSeconds = this.parseDuration(durationStr);

                const segmentTemplate = xml.querySelector('SegmentTemplate');
                const timescale = parseInt(segmentTemplate?.getAttribute('timescale') || '90000');
                const duration = parseInt(segmentTemplate?.getAttribute('duration') || '180000');
                const fragmentDuration = duration / timescale;

                this.totalFragments = Math.ceil(totalSeconds / fragmentDuration);

                log('info', `MPD Parsed: codec=${codec}, duration=${totalSeconds}s, fragmentDuration=${fragmentDuration}s, fragments=${this.totalFragments}`);

                return {
                    codec,
                    totalSeconds,
                    fragmentDuration,
                    totalFragments: this.totalFragments,
                    timescale
                };
            }

            parseDuration(duration) {
                const matches = duration.match(/PT(?:(\d+)H)?(?:(\d+)M)?(?:(\d+(?:\.\d+)?)S)?/);
                const hours = parseInt(matches?.[1] || '0');
                const minutes = parseInt(matches?.[2] || '0');
                const seconds = parseFloat(matches?.[3] || '0');
                return hours * 3600 + minutes * 60 + seconds;
            }

            async setupMediaSource(codec) {
                return new Promise((resolve, reject) => {
                    this.mediaSource = new MediaSource();
                    this.video.src = URL.createObjectURL(this.mediaSource);

                    this.mediaSource.addEventListener('sourceopen', () => {
                        try {
                            let mimeType = `video/mp4; codecs="${codec}"`;
                            log('info', `Tentando MIME type: ${mimeType}`);

                            if (!MediaSource.isTypeSupported(mimeType)) {
                                const alternatives = [
                                    'video/mp4; codecs="avc1.64001f"',
                                    'video/mp4; codecs="avc1.640028"',
                                    'video/mp4; codecs="avc1.4d401f"',
                                    'video/mp4; codecs="avc1.42E01E"',
                                    'video/mp4; codecs="avc1.42001E"',
                                    'video/mp4'
                                ];

                                let found = false;
                                for (const alt of alternatives) {
                                    if (MediaSource.isTypeSupported(alt)) {
                                        log('warning', `Codec original não suportado, usando: ${alt}`);
                                        this.sourceBuffer = this.mediaSource.addSourceBuffer(alt);
                                        found = true;
                                        break;
                                    }
                                }

                                if (!found) {
                                    reject(new Error(`Nenhum codec suportado. Original: ${mimeType}`));
                                    return;
                                }
                            } else {
                                this.sourceBuffer = this.mediaSource.addSourceBuffer(mimeType);
                            }

                            this.sourceBuffer.mode = 'segments';

                            this.sourceBuffer.addEventListener('updateend', () => this.onUpdateEnd());
                            this.sourceBuffer.addEventListener('error', (e) => log('error', 'SourceBuffer error', e));
                            this.sourceBuffer.addEventListener('abort', () => log('warning', 'SourceBuffer abort'));

                            resolve();
                        } catch (error) {
                            reject(error);
                        }
                    });

                    this.mediaSource.addEventListener('sourceended', () => log('info', 'MediaSource: sourceended'));
                    this.mediaSource.addEventListener('sourceclose', () => log('warning', 'MediaSource: sourceclose'));
                    this.mediaSource.addEventListener('error', (e) => {
                        log('error', 'MediaSource error', e);
                        reject(new Error('MediaSource error'));
                    });
                });
            }

            async fetchInitSegment() {
                const url = `${this.baseUrl}/init.mp4`;
                log('info', `Fetching init: ${url}`);

                const response = await fetch(url);
                if (!response.ok) {
                    const text = await response.text();
                    throw new Error(`Init segment error: ${response.status} - ${text}`);
                }

                const data = await response.arrayBuffer();
                log('success', `Init segment recebido: ${data.byteLength} bytes`);
                return data;
            }

            async fetchFragment(number) {
                const url = `${this.baseUrl}/fragment_${number}.m4s`;
                log('info', `Fetching fragment ${number}: ${url}`);

                const response = await fetch(url);
                if (!response.ok) {
                    if (response.status === 404 || response.status === 500) {
                        const text = await response.text();
                        log('warning', `Fragment ${number}: ${response.status} - ${text}`);
                        return null;
                    }
                    throw new Error(`Fragment ${number} error: ${response.status}`);
                }

                const data = await response.arrayBuffer();
                log('success', `Fragment ${number} recebido: ${data.byteLength} bytes`);
                return data;
            }

            async loadFragments() {
                while (this.isPlaying && this.currentFragment < this.totalFragments) {
                    try {
                        const fragment = await this.fetchFragment(this.currentFragment);

                        if (!fragment) {
                            log('info', 'Fim dos fragmentos (servidor retornou null)');
                            break;
                        }

                        this.lastFragmentData = fragment;
                        analyzeMP4Boxes(fragment, `Fragment ${this.currentFragment}`);

                        await this.appendBuffer(fragment, `fragment_${this.currentFragment}`);
                        log('success', `Fragment ${this.currentFragment} appendado`);

                        // Iniciar playback após primeiro fragmento
                        if (!this.hasStartedPlayback && this.currentFragment === 0) {
                            this.startPlayback();
                        }

                        this.currentFragment++;
                        updateStatus();

                    } catch (error) {
                        showError(`Erro no Fragment ${this.currentFragment}`, `
Message: ${error.message}
Stack: ${error.stack}

MediaSource state: ${this.mediaSource?.readyState}
SourceBuffer updating: ${this.sourceBuffer?.updating}
Video error: ${this.video.error?.message || 'none'}
                            `);
                        break;
                    }
                }

                // Finalizar stream
                if (this.mediaSource && this.mediaSource.readyState === 'open') {
                    try {
                        await this.waitForBuffer();
                        this.mediaSource.endOfStream();
                        log('success', '═══════════════════════════════════════════════════');
                        log('success', 'Stream finalizado com sucesso!');
                        log('success', '═══════════════════════════════════════════════════');
                    } catch (e) {
                        log('warning', `Erro ao finalizar stream: ${e.message}`);
                    }
                }
            }

            startPlayback() {
                this.hasStartedPlayback = true;

                const tryPlay = () => {
                    if (this.video.readyState >= 2) {
                        this.video.play()
                            .then(() => log('success', '▶ Playback iniciado automaticamente'))
                            .catch(e => log('warning', `Autoplay bloqueado: ${e.message}. Clique no vídeo para iniciar.`));
                    } else {
                        setTimeout(tryPlay, 100);
                    }
                };

                tryPlay();
            }

            appendBuffer(data, label) {
                return new Promise((resolve, reject) => {
                    if (!this.sourceBuffer) {
                        reject(new Error('SourceBuffer não existe'));
                        return;
                    }

                    if (this.mediaSource.readyState !== 'open') {
                        reject(new Error(`MediaSource não está aberto: ${this.mediaSource.readyState}`));
                        return;
                    }

                    log('info', `appendBuffer: ${label}, ${data.byteLength} bytes`);

                    this.fragmentQueue.push({ data, label, resolve, reject });
                    this.processQueue();
                });
            }

            processQueue() {
                if (this.isAppending || this.fragmentQueue.length === 0) {
                    return;
                }

                if (this.sourceBuffer.updating) {
                    return;
                }

                this.isAppending = true;
                const { data, label, resolve, reject } = this.fragmentQueue.shift();

                try {
                    this.sourceBuffer.appendBuffer(data);
                    this._currentResolve = resolve;
                    this._currentReject = reject;
                    this._currentLabel = label;
                } catch (error) {
                    this.isAppending = false;
                    log('error', `Erro síncrono ao appendar ${label}: ${error.message}`);
                    reject(error);
                    this.processQueue();
                }
            }

            onUpdateEnd() {
                this.isAppending = false;

                if (this._currentResolve) {
                    this._currentResolve();
                    this._currentResolve = null;
                    this._currentReject = null;
                }

                this.processQueue();
            }

            waitForBuffer() {
                return new Promise((resolve) => {
                    if (!this.sourceBuffer || !this.sourceBuffer.updating) {
                        resolve();
                    } else {
                        this.sourceBuffer.addEventListener('updateend', resolve, { once: true });
                    }
                });
            }
        }

        // ════════════════════════════════════════════════════════════════════
        // INSTÂNCIA E FUNÇÕES GLOBAIS
        // ════════════════════════════════════════════════════════════════════
        const player = new DASHPlayer(document.getElementById('videoPlayer'), BaseUrl);

        function playVideo() {
            const videoName = document.getElementById('videoName').value.trim();
            if (!videoName) {
                alert('Digite o nome do vídeo');
                return;
            }
            player.play(videoName);
        }

        function stopVideo() {
            player.stop();
        }

        function analyzeBuffer() {
            if (player.lastInitData) {
                analyzeMP4Boxes(player.lastInitData, 'Último Init Segment');
            }
            if (player.lastFragmentData) {
                analyzeMP4Boxes(player.lastFragmentData, 'Último Fragment');
            }
        }

        // Atualizar status periodicamente
        setInterval(updateStatus, 500);

        // Log inicial
        log('info', '═══════════════════════════════════════════════════');
        log('info', 'DASH Debug Player inicializado');
        log('info', '═══════════════════════════════════════════════════');
        log('info', `Base URL: ${BaseUrl}`);
        log('info', `MediaSource suportado: ${!!window.MediaSource}`);

        // Verificar codecs comuns
        const testCodecs = [
            'video/mp4; codecs="avc1.64001f"',
            'video/mp4; codecs="avc1.640028"',
            'video/mp4; codecs="avc1.4d401f"',
            'video/mp4; codecs="avc1.42E01E"',
            'video/mp4'
        ];

        testCodecs.forEach(codec => {
            const supported = MediaSource.isTypeSupported(codec);
            log(supported ? 'success' : 'warning', `Codec ${codec}: ${supported ? 'suportado' : 'não suportado'}`);
        });
    </script>
</body>
</html>